// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "functionalCovariance_types.h"
#include <RcppEigen.h>
#include <RcppGSL.h>
#include <Rcpp.h>

using namespace Rcpp;

// mixedMomentsC
NumericVector mixedMomentsC(NumericVector y, bool mixedOnly);
RcppExport SEXP _functionalCovariance_mixedMomentsC(SEXP ySEXP, SEXP mixedOnlySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type y(ySEXP);
    Rcpp::traits::input_parameter< bool >::type mixedOnly(mixedOnlySEXP);
    rcpp_result_gen = Rcpp::wrap(mixedMomentsC(y, mixedOnly));
    return rcpp_result_gen;
END_RCPP
}
// splineMatrixC
NumericMatrix splineMatrixC(const double lower, const double upper, const int order, const int nbreaks, const NumericVector x);
RcppExport SEXP _functionalCovariance_splineMatrixC(SEXP lowerSEXP, SEXP upperSEXP, SEXP orderSEXP, SEXP nbreaksSEXP, SEXP xSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const double >::type lower(lowerSEXP);
    Rcpp::traits::input_parameter< const double >::type upper(upperSEXP);
    Rcpp::traits::input_parameter< const int >::type order(orderSEXP);
    Rcpp::traits::input_parameter< const int >::type nbreaks(nbreaksSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type x(xSEXP);
    rcpp_result_gen = Rcpp::wrap(splineMatrixC(lower, upper, order, nbreaks, x));
    return rcpp_result_gen;
END_RCPP
}
// penaltyMatrixC
SpMat penaltyMatrixC(const NumericMatrix X, const int nzero);
RcppExport SEXP _functionalCovariance_penaltyMatrixC(SEXP XSEXP, SEXP nzeroSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const NumericMatrix >::type X(XSEXP);
    Rcpp::traits::input_parameter< const int >::type nzero(nzeroSEXP);
    rcpp_result_gen = Rcpp::wrap(penaltyMatrixC(X, nzero));
    return rcpp_result_gen;
END_RCPP
}
// singleDesignMatrixC
const SpMat singleDesignMatrixC(const SpMat dM, const int nnzero, const bool mixedOnly);
RcppExport SEXP _functionalCovariance_singleDesignMatrixC(SEXP dMSEXP, SEXP nnzeroSEXP, SEXP mixedOnlySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const SpMat >::type dM(dMSEXP);
    Rcpp::traits::input_parameter< const int >::type nnzero(nnzeroSEXP);
    Rcpp::traits::input_parameter< const bool >::type mixedOnly(mixedOnlySEXP);
    rcpp_result_gen = Rcpp::wrap(singleDesignMatrixC(dM, nnzero, mixedOnly));
    return rcpp_result_gen;
END_RCPP
}
// fullDesignC
List fullDesignC(const List indexes, const List values, const int lower, const int upper, const int nbasis, const int order, const Eigen::VectorXd weights, const bool mixedOnly);
RcppExport SEXP _functionalCovariance_fullDesignC(SEXP indexesSEXP, SEXP valuesSEXP, SEXP lowerSEXP, SEXP upperSEXP, SEXP nbasisSEXP, SEXP orderSEXP, SEXP weightsSEXP, SEXP mixedOnlySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const List >::type indexes(indexesSEXP);
    Rcpp::traits::input_parameter< const List >::type values(valuesSEXP);
    Rcpp::traits::input_parameter< const int >::type lower(lowerSEXP);
    Rcpp::traits::input_parameter< const int >::type upper(upperSEXP);
    Rcpp::traits::input_parameter< const int >::type nbasis(nbasisSEXP);
    Rcpp::traits::input_parameter< const int >::type order(orderSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type weights(weightsSEXP);
    Rcpp::traits::input_parameter< const bool >::type mixedOnly(mixedOnlySEXP);
    rcpp_result_gen = Rcpp::wrap(fullDesignC(indexes, values, lower, upper, nbasis, order, weights, mixedOnly));
    return rcpp_result_gen;
END_RCPP
}
// estimateCoefficientsC
Eigen::VectorXd estimateCoefficientsC(const List fullDesign, const SpMat penalty, const double lambda);
RcppExport SEXP _functionalCovariance_estimateCoefficientsC(SEXP fullDesignSEXP, SEXP penaltySEXP, SEXP lambdaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const List >::type fullDesign(fullDesignSEXP);
    Rcpp::traits::input_parameter< const SpMat >::type penalty(penaltySEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    rcpp_result_gen = Rcpp::wrap(estimateCoefficientsC(fullDesign, penalty, lambda));
    return rcpp_result_gen;
END_RCPP
}
// takahashiDavisC
SpMatC takahashiDavisC(const SpMat L);
RcppExport SEXP _functionalCovariance_takahashiDavisC(SEXP LSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const SpMat >::type L(LSEXP);
    rcpp_result_gen = Rcpp::wrap(takahashiDavisC(L));
    return rcpp_result_gen;
END_RCPP
}
// computePredC
Eigen::VectorXd computePredC(const SpMat dM, const Eigen::VectorXd beta, const bool mixedOnly);
RcppExport SEXP _functionalCovariance_computePredC(SEXP dMSEXP, SEXP betaSEXP, SEXP mixedOnlySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const SpMat >::type dM(dMSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const bool >::type mixedOnly(mixedOnlySEXP);
    rcpp_result_gen = Rcpp::wrap(computePredC(dM, beta, mixedOnly));
    return rcpp_result_gen;
END_RCPP
}
// computeSSEC
double computeSSEC(const List indexes, const List values, const int lower, const int upper, const int nbasis, const int order, const Eigen::VectorXd beta, const Eigen::VectorXd weights, const bool mixedOnly);
RcppExport SEXP _functionalCovariance_computeSSEC(SEXP indexesSEXP, SEXP valuesSEXP, SEXP lowerSEXP, SEXP upperSEXP, SEXP nbasisSEXP, SEXP orderSEXP, SEXP betaSEXP, SEXP weightsSEXP, SEXP mixedOnlySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const List >::type indexes(indexesSEXP);
    Rcpp::traits::input_parameter< const List >::type values(valuesSEXP);
    Rcpp::traits::input_parameter< const int >::type lower(lowerSEXP);
    Rcpp::traits::input_parameter< const int >::type upper(upperSEXP);
    Rcpp::traits::input_parameter< const int >::type nbasis(nbasisSEXP);
    Rcpp::traits::input_parameter< const int >::type order(orderSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type weights(weightsSEXP);
    Rcpp::traits::input_parameter< const bool >::type mixedOnly(mixedOnlySEXP);
    rcpp_result_gen = Rcpp::wrap(computeSSEC(indexes, values, lower, upper, nbasis, order, beta, weights, mixedOnly));
    return rcpp_result_gen;
END_RCPP
}
// generalizedCrossValidationC
double generalizedCrossValidationC(double lambda, const List indexes, const List values, const int lower_int, const int upper_int, const int nbasis, const int order, const SpMat designX, const Eigen::VectorXd designY, const SpMat penalty, const double multiplier, const Eigen::VectorXd weights, const bool mixedOnly);
RcppExport SEXP _functionalCovariance_generalizedCrossValidationC(SEXP lambdaSEXP, SEXP indexesSEXP, SEXP valuesSEXP, SEXP lower_intSEXP, SEXP upper_intSEXP, SEXP nbasisSEXP, SEXP orderSEXP, SEXP designXSEXP, SEXP designYSEXP, SEXP penaltySEXP, SEXP multiplierSEXP, SEXP weightsSEXP, SEXP mixedOnlySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< const List >::type indexes(indexesSEXP);
    Rcpp::traits::input_parameter< const List >::type values(valuesSEXP);
    Rcpp::traits::input_parameter< const int >::type lower_int(lower_intSEXP);
    Rcpp::traits::input_parameter< const int >::type upper_int(upper_intSEXP);
    Rcpp::traits::input_parameter< const int >::type nbasis(nbasisSEXP);
    Rcpp::traits::input_parameter< const int >::type order(orderSEXP);
    Rcpp::traits::input_parameter< const SpMat >::type designX(designXSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type designY(designYSEXP);
    Rcpp::traits::input_parameter< const SpMat >::type penalty(penaltySEXP);
    Rcpp::traits::input_parameter< const double >::type multiplier(multiplierSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type weights(weightsSEXP);
    Rcpp::traits::input_parameter< const bool >::type mixedOnly(mixedOnlySEXP);
    rcpp_result_gen = Rcpp::wrap(generalizedCrossValidationC(lambda, indexes, values, lower_int, upper_int, nbasis, order, designX, designY, penalty, multiplier, weights, mixedOnly));
    return rcpp_result_gen;
END_RCPP
}
// mixedMomentsCrC
NumericVector mixedMomentsCrC(NumericVector x, NumericVector y);
RcppExport SEXP _functionalCovariance_mixedMomentsCrC(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type x(xSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type y(ySEXP);
    rcpp_result_gen = Rcpp::wrap(mixedMomentsCrC(x, y));
    return rcpp_result_gen;
END_RCPP
}
// splineMatrixCrC
NumericMatrix splineMatrixCrC(const double lower, const double upper, const int order, const int nbreaks, const NumericVector x);
RcppExport SEXP _functionalCovariance_splineMatrixCrC(SEXP lowerSEXP, SEXP upperSEXP, SEXP orderSEXP, SEXP nbreaksSEXP, SEXP xSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const double >::type lower(lowerSEXP);
    Rcpp::traits::input_parameter< const double >::type upper(upperSEXP);
    Rcpp::traits::input_parameter< const int >::type order(orderSEXP);
    Rcpp::traits::input_parameter< const int >::type nbreaks(nbreaksSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type x(xSEXP);
    rcpp_result_gen = Rcpp::wrap(splineMatrixCrC(lower, upper, order, nbreaks, x));
    return rcpp_result_gen;
END_RCPP
}
// singleDesignMatrixCrC
const SpMat singleDesignMatrixCrC(const SpMat dM1, const SpMat dM2);
RcppExport SEXP _functionalCovariance_singleDesignMatrixCrC(SEXP dM1SEXP, SEXP dM2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const SpMat >::type dM1(dM1SEXP);
    Rcpp::traits::input_parameter< const SpMat >::type dM2(dM2SEXP);
    rcpp_result_gen = Rcpp::wrap(singleDesignMatrixCrC(dM1, dM2));
    return rcpp_result_gen;
END_RCPP
}
// penaltyMatrixCrC
SpMat penaltyMatrixCrC(const NumericMatrix X, const NumericMatrix Y);
RcppExport SEXP _functionalCovariance_penaltyMatrixCrC(SEXP XSEXP, SEXP YSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const NumericMatrix >::type X(XSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type Y(YSEXP);
    rcpp_result_gen = Rcpp::wrap(penaltyMatrixCrC(X, Y));
    return rcpp_result_gen;
END_RCPP
}
// fullDesignCrC
List fullDesignCrC(const List indexes1, const List values1, const List indexes2, const List values2, const NumericVector intv1, const NumericVector intv2, const IntegerVector nbasis, const IntegerVector order, const Eigen::VectorXd weights);
RcppExport SEXP _functionalCovariance_fullDesignCrC(SEXP indexes1SEXP, SEXP values1SEXP, SEXP indexes2SEXP, SEXP values2SEXP, SEXP intv1SEXP, SEXP intv2SEXP, SEXP nbasisSEXP, SEXP orderSEXP, SEXP weightsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const List >::type indexes1(indexes1SEXP);
    Rcpp::traits::input_parameter< const List >::type values1(values1SEXP);
    Rcpp::traits::input_parameter< const List >::type indexes2(indexes2SEXP);
    Rcpp::traits::input_parameter< const List >::type values2(values2SEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type intv1(intv1SEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type intv2(intv2SEXP);
    Rcpp::traits::input_parameter< const IntegerVector >::type nbasis(nbasisSEXP);
    Rcpp::traits::input_parameter< const IntegerVector >::type order(orderSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type weights(weightsSEXP);
    rcpp_result_gen = Rcpp::wrap(fullDesignCrC(indexes1, values1, indexes2, values2, intv1, intv2, nbasis, order, weights));
    return rcpp_result_gen;
END_RCPP
}
// estimateCoefficientsCrC
Eigen::VectorXd estimateCoefficientsCrC(const List fullDesign, const SpMat penalty, const double lambda);
RcppExport SEXP _functionalCovariance_estimateCoefficientsCrC(SEXP fullDesignSEXP, SEXP penaltySEXP, SEXP lambdaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const List >::type fullDesign(fullDesignSEXP);
    Rcpp::traits::input_parameter< const SpMat >::type penalty(penaltySEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    rcpp_result_gen = Rcpp::wrap(estimateCoefficientsCrC(fullDesign, penalty, lambda));
    return rcpp_result_gen;
END_RCPP
}
// takahashiDavisCrC
SpMatC takahashiDavisCrC(const SpMat L);
RcppExport SEXP _functionalCovariance_takahashiDavisCrC(SEXP LSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const SpMat >::type L(LSEXP);
    rcpp_result_gen = Rcpp::wrap(takahashiDavisCrC(L));
    return rcpp_result_gen;
END_RCPP
}
// computeSSECrC
double computeSSECrC(const List indexes1, const List values1, const List indexes2, const List values2, const NumericVector intv1, const NumericVector intv2, const IntegerVector nbasis, const IntegerVector order, const Eigen::VectorXd beta, const Eigen::VectorXd weights);
RcppExport SEXP _functionalCovariance_computeSSECrC(SEXP indexes1SEXP, SEXP values1SEXP, SEXP indexes2SEXP, SEXP values2SEXP, SEXP intv1SEXP, SEXP intv2SEXP, SEXP nbasisSEXP, SEXP orderSEXP, SEXP betaSEXP, SEXP weightsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const List >::type indexes1(indexes1SEXP);
    Rcpp::traits::input_parameter< const List >::type values1(values1SEXP);
    Rcpp::traits::input_parameter< const List >::type indexes2(indexes2SEXP);
    Rcpp::traits::input_parameter< const List >::type values2(values2SEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type intv1(intv1SEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type intv2(intv2SEXP);
    Rcpp::traits::input_parameter< const IntegerVector >::type nbasis(nbasisSEXP);
    Rcpp::traits::input_parameter< const IntegerVector >::type order(orderSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type weights(weightsSEXP);
    rcpp_result_gen = Rcpp::wrap(computeSSECrC(indexes1, values1, indexes2, values2, intv1, intv2, nbasis, order, beta, weights));
    return rcpp_result_gen;
END_RCPP
}
// generalizedCrossValidationCrC
double generalizedCrossValidationCrC(double lambda, const List indexes1, const List values1, const List indexes2, const List values2, const NumericVector intv1, const NumericVector intv2, const IntegerVector nbasis, const IntegerVector order, const SpMat designX, const Eigen::VectorXd designY, const SpMat penalty, const double multiplier, const Eigen::VectorXd weights);
RcppExport SEXP _functionalCovariance_generalizedCrossValidationCrC(SEXP lambdaSEXP, SEXP indexes1SEXP, SEXP values1SEXP, SEXP indexes2SEXP, SEXP values2SEXP, SEXP intv1SEXP, SEXP intv2SEXP, SEXP nbasisSEXP, SEXP orderSEXP, SEXP designXSEXP, SEXP designYSEXP, SEXP penaltySEXP, SEXP multiplierSEXP, SEXP weightsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< const List >::type indexes1(indexes1SEXP);
    Rcpp::traits::input_parameter< const List >::type values1(values1SEXP);
    Rcpp::traits::input_parameter< const List >::type indexes2(indexes2SEXP);
    Rcpp::traits::input_parameter< const List >::type values2(values2SEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type intv1(intv1SEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type intv2(intv2SEXP);
    Rcpp::traits::input_parameter< const IntegerVector >::type nbasis(nbasisSEXP);
    Rcpp::traits::input_parameter< const IntegerVector >::type order(orderSEXP);
    Rcpp::traits::input_parameter< const SpMat >::type designX(designXSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type designY(designYSEXP);
    Rcpp::traits::input_parameter< const SpMat >::type penalty(penaltySEXP);
    Rcpp::traits::input_parameter< const double >::type multiplier(multiplierSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type weights(weightsSEXP);
    rcpp_result_gen = Rcpp::wrap(generalizedCrossValidationCrC(lambda, indexes1, values1, indexes2, values2, intv1, intv2, nbasis, order, designX, designY, penalty, multiplier, weights));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_functionalCovariance_mixedMomentsC", (DL_FUNC) &_functionalCovariance_mixedMomentsC, 2},
    {"_functionalCovariance_splineMatrixC", (DL_FUNC) &_functionalCovariance_splineMatrixC, 5},
    {"_functionalCovariance_penaltyMatrixC", (DL_FUNC) &_functionalCovariance_penaltyMatrixC, 2},
    {"_functionalCovariance_singleDesignMatrixC", (DL_FUNC) &_functionalCovariance_singleDesignMatrixC, 3},
    {"_functionalCovariance_fullDesignC", (DL_FUNC) &_functionalCovariance_fullDesignC, 8},
    {"_functionalCovariance_estimateCoefficientsC", (DL_FUNC) &_functionalCovariance_estimateCoefficientsC, 3},
    {"_functionalCovariance_takahashiDavisC", (DL_FUNC) &_functionalCovariance_takahashiDavisC, 1},
    {"_functionalCovariance_computePredC", (DL_FUNC) &_functionalCovariance_computePredC, 3},
    {"_functionalCovariance_computeSSEC", (DL_FUNC) &_functionalCovariance_computeSSEC, 9},
    {"_functionalCovariance_generalizedCrossValidationC", (DL_FUNC) &_functionalCovariance_generalizedCrossValidationC, 13},
    {"_functionalCovariance_mixedMomentsCrC", (DL_FUNC) &_functionalCovariance_mixedMomentsCrC, 2},
    {"_functionalCovariance_splineMatrixCrC", (DL_FUNC) &_functionalCovariance_splineMatrixCrC, 5},
    {"_functionalCovariance_singleDesignMatrixCrC", (DL_FUNC) &_functionalCovariance_singleDesignMatrixCrC, 2},
    {"_functionalCovariance_penaltyMatrixCrC", (DL_FUNC) &_functionalCovariance_penaltyMatrixCrC, 2},
    {"_functionalCovariance_fullDesignCrC", (DL_FUNC) &_functionalCovariance_fullDesignCrC, 9},
    {"_functionalCovariance_estimateCoefficientsCrC", (DL_FUNC) &_functionalCovariance_estimateCoefficientsCrC, 3},
    {"_functionalCovariance_takahashiDavisCrC", (DL_FUNC) &_functionalCovariance_takahashiDavisCrC, 1},
    {"_functionalCovariance_computeSSECrC", (DL_FUNC) &_functionalCovariance_computeSSECrC, 10},
    {"_functionalCovariance_generalizedCrossValidationCrC", (DL_FUNC) &_functionalCovariance_generalizedCrossValidationCrC, 14},
    {NULL, NULL, 0}
};

RcppExport void R_init_functionalCovariance(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
